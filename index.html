<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>択一ドリル（ランダム — 一括表示）</title>
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
<link href="https://cdn.tailwindcss.com" rel="stylesheet">
<style>
  body { font-family: "Noto Sans JP", "Inter", sans-serif; }
  .option { transition: background-color .14s, border-color .14s; cursor: pointer; }
  .correct { background:#e6fffa; border-color:#38a169; color:#2f855a; }
  .incorrect { background:#fff5f5; border-color:#e53e3e; color:#c53030; }
  .answered { cursor: default; pointer-events: none; opacity: .95; }
  .explanation { display:none; margin-top:.5rem; padding:.6rem; background:#f7fafc; border-left:4px solid #4a5568; color:#2d3748; }
  .hint { display:none; margin-top:.5rem; padding:.5rem; background:#fffaf0; border-left:4px solid #b7791f; color:#7a5a00; }
  .card { min-width: 0; } /* for tailwind */
</style>
</head>
<body class="bg-gray-100 text-gray-900 p-6">
  <div class="max-w-5xl mx-auto">
    <header class="text-center mb-4">
      <h1 class="text-2xl font-bold">建設コンサルタント 択一ドリル（ランダム・一括表示）</h1>
      <p class="text-sm text-gray-600 mt-1">CSVを読み込み、条件で除外した上でランダム抽出した問題を一度に表示します。正解時はドレミ音、誤答は無音。</p>
    </header>

    <!-- コントロール -->
    <section class="bg-white p-4 rounded shadow mb-4">
      <div class="grid grid-cols-1 sm:grid-cols-4 gap-3">
        <div>
          <label class="block text-sm font-medium mb-1">CSV（ジャンル）</label>
          <select id="csvSelect" class="w-full border p-2 rounded"></select>
        </div>
        <div>
          <label class="block text-sm font-medium mb-1">出題数</label>
          <select id="numSelect" class="w-full border p-2 rounded">
            <option value="5">5問</option>
            <option value="10" selected>10問</option>
            <option value="20">20問</option>
          </select>
        </div>
        <div>
          <label class="block text-sm font-medium mb-1">音（正解）</label>
          <div class="flex items-center gap-2">
            <input id="soundToggle" type="checkbox" checked />
            <label for="soundToggle" class="text-sm">ドレミを鳴らす</label>
          </div>
        </div>
        <div class="flex items-end gap-2">
          <button id="loadBtn" class="bg-blue-600 text-white px-4 py-2 rounded">読み込んで出題</button>
          <button id="retryBtn" class="bg-indigo-500 text-white px-4 py-2 rounded">もう一度挑戦</button>
        </div>
      </div>

      <div class="mt-3 grid grid-cols-1 sm:grid-cols-2 gap-3">
        <div>
          <label class="text-sm font-medium">除外 — 最低正解回数</label>
          <input id="minCorrect" type="number" min="1" value="3" class="w-full border p-2 rounded" />
          <p class="text-xs text-gray-500 mt-1">例: 3回以上正解している問題は除外</p>
        </div>
        <div>
          <label class="text-sm font-medium">除外 — 正答率（％）</label>
          <input id="minRate" type="number" min="0" max="100" value="80" class="w-full border p-2 rounded" />
          <p class="text-xs text-gray-500 mt-1">例: 正答率 80% 以上の問題は除外</p>
        </div>
      </div>

      <div class="mt-4 flex gap-2">
        <button id="clearStats" class="bg-gray-200 px-3 py-2 rounded">学習ログをクリア</button>
        <button id="showStats" class="bg-gray-200 px-3 py-2 rounded">統計を見る</button>
        <span id="notice" class="text-sm text-red-600 ml-3"></span>
      </div>
    </section>

    <!-- 問題一括表示領域 -->
    <main id="quizArea" class="space-y-4"></main>

    <footer class="text-center text-xs text-gray-500 mt-6">
      CSVは同フォルダに配置。index.json があれば自動でファイル一覧を取得（なければ内部配列）。CSVヘッダ推奨：問題,正解,選択肢2,選択肢3,選択肢4,解説,ヒント
    </footer>
  </div>

<script>
/* ---------------- 設定 ---------------- */
const csvFilesFallback = ["4-1.csv","4-2.csv","4-3.csv"]; // 必要なら編集
const STORAGE_KEY = "quizStats_v1";

/* ---------------- DOM ---------------- */
const csvSelect = document.getElementById("csvSelect");
const loadBtn = document.getElementById("loadBtn");
const retryBtn = document.getElementById("retryBtn");
const quizArea = document.getElementById("quizArea");
const numSelect = document.getElementById("numSelect");
const minCorrectInput = document.getElementById("minCorrect");
const minRateInput = document.getElementById("minRate");
const soundToggle = document.getElementById("soundToggle");
const clearStatsBtn = document.getElementById("clearStats");
const showStatsBtn = document.getElementById("showStats");
const notice = document.getElementById("notice");

/* ---- 初期化: index.json 試行 -> フォールバック ---- */
(async function init() {
  let list = [];
  try {
    const r = await fetch("index.json");
    if (r.ok) list = await r.json();
  } catch(e){ /* ignore */ }
  if (!Array.isArray(list) || list.length===0) list = csvFilesFallback;
  list.forEach(f => {
    const opt = document.createElement("option");
    opt.value = f; opt.textContent = f;
    csvSelect.appendChild(opt);
  });
})();

/* ---- WebAudio: playDoReMi ---- */
let audioCtx = null;
function ensureAudioCtx(){ if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
function playTone(freq, startOffset, duration=0.16){
  ensureAudioCtx();
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = "sine";
  o.frequency.value = freq;
  o.connect(g); g.connect(audioCtx.destination);
  const now = audioCtx.currentTime + startOffset;
  g.gain.setValueAtTime(0.0001, now);
  g.gain.exponentialRampToValueAtTime(0.18, now+0.01);
  g.gain.exponentialRampToValueAtTime(0.0001, now+duration);
  o.start(now); o.stop(now+duration+0.02);
}
function playDoReMi(){
  playTone(261.63, 0);
  playTone(293.66, 0.16);
  playTone(329.63, 0.32);
}

/* ---- CSV -> questions 構築（あなたの1行1問形式対応） ---- */
function buildQuestionsFromCSV(text, filename){
  const parsed = Papa.parse(text, { header:true, skipEmptyLines:true });
  const rows = parsed.data;
  const questions = [];
  rows.forEach((row, idx) => {
    // 柔軟にヘッダ名を拾う
    const qText = row["問題"] ?? row["question"] ?? Object.values(row)[0] ?? "";
    const colCorrect = row["正解"] ?? row["answer"] ?? Object.values(row)[1] ?? "";
    const col2 = row["選択肢2"] ?? Object.values(row)[2] ?? "";
    const col3 = row["選択肢3"] ?? Object.values(row)[3] ?? "";
    const col4 = row["選択肢4"] ?? Object.values(row)[4] ?? "";
    const explanation = row["解説"] ?? Object.values(row)[5] ?? "";
    const hint = row["ヒント"] ?? Object.values(row)[6] ?? "";

    // raw options: if colCorrect contains multiple "a. .., b. .." style, split. Otherwise use sequential.
    let rawOptions = [];
    const looksLikeMultiple = /[aA][\.\．\)]\s*[^,]+[,，]\s*[bB]/.test(colCorrect);
    if (looksLikeMultiple) {
      rawOptions = colCorrect.split(/[,，]\s*/).map(s=>s.trim()).filter(Boolean);
      [col2,col3,col4].forEach(c=>{ if(c && !rawOptions.includes(c.trim())) rawOptions.push(c.trim()); });
    } else {
      if (colCorrect && colCorrect.toString().trim()) rawOptions.push(colCorrect.toString().trim());
      if (col2 && col2.toString().trim()) rawOptions.push(col2.toString().trim());
      if (col3 && col3.toString().trim()) rawOptions.push(col3.toString().trim());
      if (col4 && col4.toString().trim()) rawOptions.push(col4.toString().trim());
    }
    if (!qText || rawOptions.length === 0) return;
    // normalize label->text
    const optionsMap = {};
    const labels = ["a","b","c","d","e","f"];
    rawOptions.forEach((opt,i)=>{
      const m = opt.match(/^([a-zA-Z一二三四五六七八九十0-9]+)[\.\．\)]\s*(.*)$/);
      if (m && m[2]) {
        const label = m[1].toString().toLowerCase();
        optionsMap[label] = m[2].trim();
      } else {
        optionsMap[labels[i]] = opt.trim();
      }
    });
    // determine correct label
    let correctLabel = null;
    const simpleLabelMatch = (colCorrect || "").toString().trim().match(/^[a-dA-D]$/);
    if (simpleLabelMatch) correctLabel = simpleLabelMatch[0].toLowerCase();
    else {
      const firstOpt = rawOptions[0];
      const m2 = firstOpt.match(/^([a-zA-Z一二三四五六七八九十0-9]+)[\.\．\)]/);
      if (m2) correctLabel = m2[1].toLowerCase();
      else correctLabel = Object.keys(optionsMap)[0];
    }
    const qid = `${filename}::${idx+1}`;
    questions.push({ id: qid, question: qText.trim(), options: optionsMap, answer: correctLabel, explanation: (explanation||"").trim(), hint: (hint||"").trim() });
  });
  return questions;
}

/* ---- stats 操作 ---- */
function loadStats(){ try{ return JSON.parse(localStorage.getItem(STORAGE_KEY) || "{}"); }catch(e){return{}} }
function saveStats(obj){ localStorage.setItem(STORAGE_KEY, JSON.stringify(obj)); }
function clearStats(){ localStorage.removeItem(STORAGE_KEY); alert("学習ログをクリアしました"); }

/* ---- 除外判定 ---- */
function shouldExclude(q, stats, minCorrect, minRate){
  const rec = stats[q.id] || { correct:0, total:0 };
  if (rec.total === 0) return false;
  const rate = rec.total>0 ? (rec.correct/rec.total)*100 : 0;
  return (rec.correct >= minCorrect) && (rate >= minRate);
}

/* ---- 出題（全問一括レンダリング） ---- */
let currentSet = [], statsCache = loadStats();

async function loadAndRender() {
  notice.textContent = "";
  quizArea.innerHTML = "";
  statsCache = loadStats();

  const filename = csvSelect.value;
  const num = parseInt(numSelect.value,10) || 10;
  const minCorrect = parseInt(minCorrectInput.value,10) || 3;
  const minRate = parseFloat(minRateInput.value) || 80;

  try {
    const r = await fetch(filename);
    if (!r.ok) throw new Error("CSV取得失敗: "+r.status);
    const text = await r.text();
    const all = buildQuestionsFromCSV(text, filename);

    let candidates = all.filter(q => !shouldExclude(q, statsCache, minCorrect, minRate));
    if (candidates.length < num) {
      notice.textContent = `候補が不足しています（${candidates.length}/${num}）。除外中の問題を含めて補充します。`;
      const excluded = all.filter(q => shouldExclude(q, statsCache, minCorrect, minRate));
      candidates.push(...excluded);
    }
    shuffleArray(candidates);
    currentSet = candidates.slice(0, Math.min(num, candidates.length));
    renderAll(currentSet);
  } catch(err) {
    quizArea.innerHTML = `<div class="bg-red-50 p-4 rounded text-red-700">読み込みエラー: ${err.message}</div>`;
    console.error(err);
  }
}

/* 一括描画 */
function renderAll(set){
  quizArea.innerHTML = "";
  set.forEach((q, idx) => {
    const card = document.createElement("div");
    card.className = "card bg-white p-5 rounded shadow";

    // header
    const header = document.createElement("div");
    header.className = "flex justify-between items-start";
    header.innerHTML = `<div class="text-sm text-gray-600">問 ${idx+1}</div><div class="text-xs text-gray-500">${q.id}</div>`;
    card.appendChild(header);

    // question
    const p = document.createElement("p");
    p.className = "font-bold text-lg mt-2";
    p.textContent = q.question;
    card.appendChild(p);

    // buttons row (hint & stats)
    const btnRow = document.createElement("div");
    btnRow.className = "mt-3 flex items-center gap-3";
    const hintBtn = document.createElement("button");
    hintBtn.className = "bg-yellow-300 text-black px-3 py-1 rounded text-sm";
    hintBtn.textContent = "ヒント";
    const st = statsCache[q.id] || { correct:0, total:0 };
    const statSpan = document.createElement("div");
    statSpan.className = "text-sm text-gray-500";
    statSpan.textContent = `これまで: 正答 ${st.correct} / 試行 ${st.total}`;
    btnRow.appendChild(hintBtn);
    btnRow.appendChild(statSpan);
    card.appendChild(btnRow);

    // hint element
    const hintEl = document.createElement("div");
    hintEl.className = "hint";
    hintEl.innerHTML = `<strong>ヒント:</strong> ${q.hint || "（なし）"}`;
    card.appendChild(hintEl);

    hintBtn.addEventListener("click", () => {
      hintEl.style.display = hintEl.style.display === "block" ? "none" : "block";
    });

    // options
    const opts = document.createElement("div");
    opts.className = "mt-4 grid grid-cols-1 gap-3";
    const order = Object.keys(q.options);
    order.forEach(lbl => {
      const txt = q.options[lbl];
      const opt = document.createElement("div");
      opt.className = "option border border-gray-300 p-3 rounded-lg flex justify-between items-center";
      opt.dataset.label = lbl;
      opt.innerHTML = `<span><span class="font-bold mr-2">${lbl}.</span>${txt}</span><span class="feedback-icon"></span>`;
      opt.addEventListener("click", () => onOptionClickCard(opt, q, card, statSpan));
      opts.appendChild(opt);
    });
    card.appendChild(opts);

    // explanation
    const exp = document.createElement("div");
    exp.className = "explanation";
    exp.innerHTML = `<p><strong>【解説】</strong> ${q.explanation || "（解説なし）"}</p>`;
    card.appendChild(exp);

    quizArea.appendChild(card);
  });
}

/* 回答処理（カード版） */
function onOptionClickCard(optEl, q, cardEl, statSpan){
  if (optEl.classList.contains("answered") || optEl.closest(".card").querySelectorAll(".answered").length>0) return;
  const selected = optEl.dataset.label;
  const correct = q.answer;
  // disable all options in this card
  const opts = cardEl.querySelectorAll(".option");
  opts.forEach(o => o.classList.add("answered"));

  // mark correct
  opts.forEach(o => { if (o.dataset.label === correct) o.classList.add("correct"); });

  if (selected === correct) {
    optEl.classList.add("correct");
    if (soundToggle.checked) playDoReMi();
  } else {
    optEl.classList.add("incorrect");
    // no wrong sound
  }

  // show explanation
  const exp = cardEl.querySelector(".explanation");
  if (exp) exp.style.display = "block";

  // update stats
  const stats = loadStats();
  if (!stats[q.id]) stats[q.id] = { correct:0, total:0 };
  stats[q.id].total = (stats[q.id].total || 0) + 1;
  if (selected === correct) stats[q.id].correct = (stats[q.id].correct || 0) + 1;
  saveStats(stats);
  statsCache = stats;
  const s = stats[q.id];
  statSpan.textContent = `これまで: 正答 ${s.correct} / 試行 ${s.total}`;
}

/* ユーティリティ */
function shuffleArray(a){ for (let i=a.length-1;i>0;i--){ const j = Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } }

/* イベント */
loadBtn.addEventListener("click", () => loadAndRender());
retryBtn.addEventListener("click", () => {
  // 再抽出して同条件で再出題
  loadAndRender();
});
clearStatsBtn.addEventListener("click", () => {
  if (confirm("学習ログを完全に削除します。よいですか？")) { clearStats(); statsCache = loadStats(); alert("クリアしました"); }
});
showStatsBtn.addEventListener("click", () => {
  const s = loadStats();
  const keys = Object.keys(s);
  if (keys.length === 0) return alert("統計はありません。");
  let msg = "問題ID — 正答 / 試行\n\n";
  keys.forEach(k => { msg += `${k} — ${s[k].correct} / ${s[k].total}\n`; });
  if (msg.length>2000) { console.log(s); return alert("統計はコンソールに出力しました（長いため）。"); }
  alert(msg);
});
</script>
</body>
</html>
